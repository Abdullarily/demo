package Ne_Zabivay_bot.demo.variables;

import Ne_Zabivay_bot.demo.config.DBConnection;

import java.sql.Connection;
import java.sql.Statement;

public class Text {
        public static String javaCore() {
            return "Java Core — это термин, который может использоваться по-разному в разных контекстах." +
                    " Если он встречается в вакансиях на разработчика уровня Junior, то под ним обычно подразумевается" +
                    " базовое знание языка Java.\nНо компания Sun Microsystems, в которой разработали язык Java, определяет" +
                    " Core Java как вычислительную платформу, основанную на Java.";
        }
        public static String spring() {
            return "Spring - это универсальный фреймворк с открытым исходным кодом для Java-платформы." +
                    "\nНесмотря на то, что Spring не обеспечивал какую-либо конкретную модель программирования," +
                    " он стал широко распространённым в Java-сообществе главным образом как альтернатива и замена" +
                    " модели Enterprise JavaBeans. Spring предоставляет бо́льшую свободу Java-разработчикам в" +
                    " проектировании; кроме того, он предоставляет хорошо документированные и лёгкие в использовании " +
                    "средства решения проблем, возникающих при создании приложений корпоративного масштаба.";
        }
        public static String tgBot() {
            return "Боты — специальные аккаунты в Telegram, созданные для того, чтобы автоматически обрабатывать" +
                    " и отправлять сообщения. Пользователи могут взаимодействовать с ботами при помощи сообщений," +
                    " отправляемых через обычные или групповые чаты. Логика бота контролируется при помощи HTTPS" +
                    " запросов к нашему API для ботов. \n тут вы можете посмотреть информацию для разработчиков" +
                    "\n https://tlgrm.ru/docs/bots";
        }

    public static String lists() {
            return "Для хранения наборов данных в Java предназначены массивы. Однако их не всегда удобно использовать," +
                    " прежде всего потому, что они имеют фиксированную длину. Эту проблему в Java решают коллекции." +
                    " Однако суть не только в гибких по размеру наборах объектов, но в и том, что классы коллекций " +
                    "реализуют различные алгоритмы и структуры данных, например, такие как стек, очередь, дерево и " +
                    "ряд других.";
    }
    public static String interfaceCollection() {
            return "Хотя в Java существует множество коллекций, но все они образуют стройную и логичную систему." +
                    " Во-первых, в основе всех коллекций лежит применение того или иного интерфейса, который определяет" +
                    " базовый функционал. Среди этих интерфейсов можно выделить следующие:";
    }
    public static String extendsCollection() {
            return """
                    Эти интерфейсы частично реализуются абстрактными классами:\s
                    
                    Collection ▶: базовый интерфейс для всех коллекций и других интерфейсов коллекций

                    Queue ▶: наследует интерфейс Collection и представляет функционал для структур данных в виде очереди

                    Deque ▶: наследует интерфейс Queue и представляет функционал для двунаправленных очередей

                    List ▶: наследует интерфейс Collection и представляет функциональность простых списков

                    Set ▶: также расширяет интерфейс Collection и используется для хранения множеств уникальных объектов

                    SortedSet ▶: расширяет интерфейс Set для создания сортированных коллекций

                    NavigableSet ▶: расширяет интерфейс SortedSet для создания коллекций, в которых можно осуществлять поиск по соответствию

                    Map ▶: предназначен для созданий структур данных в виде словаря, где каждый элемент имеет определенный ключ и значение. В отличие от других интерфейсов коллекций не наследуется от интерфейса Collection""";
    }
    public static String abstractCollectionClass() {
            return """
                    AbstractCollection ▶: базовый абстрактный класс для других коллекций, который применяет интерфейс Collection
                                        
                    AbstractList ▶: расширяет класс AbstractCollection и применяет интерфейс List, предназначен для создания коллекций в виде списков
                                        
                    AbstractSet ▶: расширяет класс AbstractCollection и применяет интерфейс Set для создания коллекций в виде множеств
                                        
                    AbstractQueue ▶: расширяет класс AbstractCollection и применяет интерфейс Queue, предназначен для создания коллекций в виде очередей и стеков
                                        
                    AbstractSequentialList ▶: также расширяет класс AbstractList и реализует интерфейс List. Используется для создания связанных списков
                                        
                    AbstractMap ▶: применяет интерфейс Map, предназначен для создания наборов по типу словаря с объектами в виде пары "ключ-значение"
                    """;
    }
    public static String collectionTypes() {
            return """
                    С помощью применения вышеописанных интерфейсов и абстрактных классов в Java реализуется широкая палитра классов коллекций - списки, множества, очереди, отображения и другие, среди которых можно выделить следующие:
                    
                    ArrayList ▶: простой список объектов
                                        
                    LinkedList ▶: представляет связанный список
                                        
                    ArrayDeque ▶: класс двунаправленной очереди, в которой мы можем произвести вставку и удаление как в начале коллекции, так и в ее конце
                                        
                    HashSet ▶: набор объектов или хеш-множество, где каждый элемент имеет ключ - уникальный хеш-код
                                        
                    TreeSet ▶: набор отсортированных объектов в виде дерева
                                        
                    LinkedHashSet ▶: связанное хеш-множество
                                        
                    PriorityQueue ▶: очередь приоритетов
                                        
                    HashMap ▶: структура данных в виде словаря, в котором каждый объект имеет уникальный ключ и некоторое значение
                                        
                    TreeMap ▶: структура данных в виде дерева, где каждый элемент имеет уникальный ключ и некоторое значение
                    
                    
                    Выберите коллекцию что бы посмотреть ее методы
                                                                     ↘⬇⬇⬇⬇↙
                    """;
    }

    public static String collectionMethods() {
            return """
                    проверка текста
                    """;
    }

    public static String arrayList() {
            return """
                    💊 void add(int index, Object element) 💊
                    Вставляет указанный элемент в указанный индекс позиции в этом списке. Выбрасывает IndexOutOfBoundsException, если указанный индекс выходит за допустимые пределы (index < 0 || index > size()).
                    
                    💊 boolean add(Object o) 💊
                    Добавляет указанный элемент в конец этого списка.
                    
                    💊 boolean addAll(Collection c) 💊
                    Добавляет все элементы в указанной коллекции в конец этого списка в том порядке, в котором они возвращаются итератором указанной коллекции. Вызывает NullPointerException, если указанная коллекция имеет значение null (нулевая).
                    
                    💊 boolean addAll(int index, Collection c) 💊
                    Вставляет все элементы указанной коллекции в этот список, начиная с указанной позиции. Вызывает NullPointerException, если указанная коллекция имеет значение null.
                    
                    💊 void clear() 💊
                    Удаляет все элементы из этого списка.
                    
                    💊 Object clone() 💊
                    Возвращает неглубокую копию этого массива.
                    
                    💊 boolean contains(Object o) 💊
                    Возвращает true, если этот список содержит указанный элемент. Если точнее, то возвращает true тогда и только тогда, когда этот список содержит хотя бы один элемент e такой, что (o==null ? e==null : o.equals(e)).
                    
                    💊 void ensureCapacity(int minCapacity) 💊
                    Увеличивает емкость этого экземпляра ArrayList, если это необходимо, чтобы гарантировать, что он может удерживать, по крайней мере, количество элементов, заданных аргументом минимальной емкости.
                    
                    💊 Object get(int index) 💊
                    Возвращает элемент в указанной позиции в этом списке. Вызывает IndexOutOfBoundsException, если указанный индекс выходит за допустимые пределы (index < 0 || index >= size()).
                    
                    
                    💊 int indexOf(Object o) 💊
                    Возвращает индекс в этом списке первого упоминания указанного элемента или -1, если List не содержит этот элемент.
                    
                    
                    💊 int lastIndexOf(Object o) 💊
                    Возвращает индекс в этом списке последнего упоминания указанного элемента или -1, если List не содержит этот элемент.
                    
                    
                    💊 Object remove(int index) 💊
                    Удаляет элемент в указанной позиции в этом списке. Вызывает IndexOutOfBoundsException, если индекс выходит за допустимые пределы (index < 0 || index >= size()).
                    
                    
                    💊 protected void removeRange(int fromIndex, int toIndex) 💊
                    Удаляет из этого списка все элементы, индекс которых находится между fromIndex, включительно, и toIndex, исключительно.
                    
                    
                    💊 Object set(int index, Object element) 💊
                    Заменяет элемент в указанной позиции в этом списке указанным элементом. Вызывает IndexOutOfBoundsException, если указанный индекс выходит за допустимые пределы (index < 0 || index >= size()).
                    
                    
                    💊 int size() 💊
                    Возвращает количество элементов в этом списке.
                    
                    
                    💊 Object[] toArray() 💊
                    Возвращает массив, содержащий все элементы в этом списке в правильном порядке. Вызывает NullPointerException, если указанный массив равен null (нулевой).
                    
                    
                    💊 Object[] toArray(Object[] a) 💊
                    Возвращает массив, содержащий все элементы в этом списке в правильном порядке; тип выполнения возвращаемого массива - тип указанного массива.
                    
                    
                    💊 void trimToSize() 💊
                    Обрезает емкость этого экземпляра ArrayList до его текущих размеров
                    """;
    }
    public static String linkedList() {
            return """
                    💊 	void add(int index, Object element) 💊
                    Вставляет указанный элемент в указанный указатель позиции в этом списке. Вызывает IndexOutOfBoundsException, если указанный индекс выходит за допустимые пределы (index < 0 || index > size()).
                    
                    💊 	boolean add(Object o) 💊
                    Добавляет указанный элемент в конец этого списка.
                    
                    💊 	boolean addAll(Collection c) 💊
                    Добавляет все элементы в указанной коллекции в конец этого списка в том порядке, в котором они возвращаются итератором указанной коллекции. Выбрасывает NullPointerException, если указанная коллекция имеет значение null (нуль).
                    
                    💊 	boolean addAll(int index, Collection c) 💊
                    Вставляет все элементы указанной коллекции в этот список, начиная с указанной позиции. Вызывает NullPointerException, если указанная коллекция имеет значение null (нуль).
                    
                    💊  void addFirst(Object o) 💊
                    Вставляет данный элемент в начало этого списка.
                    
                    💊 	void addLast(Object o) 💊
                    Добавляет данный элемент в конец этого списка.
                    
                    💊 	void clear() 💊
                    Удаляет все элементы из этого списка.
                    
                    💊 	Object clone() 💊
                    Возвращает мелкую копию этого LinkedList.
                    
                    💊 	boolean contains(Object o) 💊
                    Возвращает true, если этот список содержит указанный элемент. Если точнее, то возвращает true тогда и только тогда, когда этот список содержит хотя бы один элемент e такой, что (o==null ? e==null : o.equals(e)).
                    
                    💊 	Object get(int index) 💊
                    Возвращает элемент в указанной позиции в этом списке. Вызывает IndexOutOfBoundsException, если указанный индекс выходит за допустимые пределы (index < 0 || index >= size()).
                    
                    💊 	Object getFirst() 💊
                    Возвращает первый элемент в этом списке. Вызывает исключение NoSuchElementException, если этот список пуст.
                    
                    💊 	Object getLast() 💊
                    Возвращает последний элемент в этом списке. Вызывает исключение NoSuchElementException, если этот список пуст.
                    
                    💊 	int indexOf(Object o) 💊
                    Возвращает индекс в этом списке первого упоминания указанного элемента или -1, если список не содержит этот элемент.
                    
                    💊 	int lastIndexOf(Object o) 💊
                    Возвращает индекс в этом списке последнего упоминания указанного элемента или -1, если список не содержит этот элемент.
                    
                    💊 	ListIterator listIterator(int index) 💊
                    Возвращает список-итератор элементов в этом списке (в правильной последовательности), начиная с указанной позиции в списке. Вызывает IndexOutOfBoundsException, если указанный индекс выходит за пределы диапазона (index < 0 || index >= size()).
                    
                    💊 	Object remove(int index) 💊
                    Удаляет элемент в указанной позиции в этом списке. Вызывает исключение NoSuchElementException, если этот список пуст.
                    
                    💊 	boolean remove(Object o) 💊
                    Удаляет первое упоминание указанного элемента в этом списке. Вызывает исключение NoSuchElementException, если этот список пуст. Вызывает IndexOutOfBoundsException, если указанный индекс выходит за пределы диапазона (index < 0 || index >= size()).
                    
                    💊 	Object removeFirst() 💊
                    Удаляет и возвращает первый элемент из этого списка. Выбрасывает исключение NoSuchElementException, если этот список пуст.
                    
                    💊 	Object removeLast() 💊
                    Удаляет и возвращает последний элемент из этого списка. Вызывает исключение NoSuchElementException, если этот список пуст.
                    
                    💊 	Object set(int index, Object element) 💊
                    Заменяет элемент в указанной позиции в этом списке указанным элементом. Вызывает IndexOutOfBoundsException, если указанный индекс выходит за пределы диапазона (index < 0 || index >= size()).
                    
                    💊 	int size() 💊
                    Возвращает количество элементов в этом списке.
                    
                    💊 	Object[] toArray() 💊
                    Возвращает массив, содержащий все элементы в этом списке в правильном порядке. Выбрасывает NullPointerException, если указанный массив равен null (нулю).
                    
                    💊 	Object[] toArray(Object[] a) 💊
                    Возвращает массив, содержащий все элементы в этом списке в правильном порядке; тип выполнения возвращаемого массива - тип указанного массива.
                    """;
    }

    public static String arrayDeque() {
            return """
                    💊 public boolean add(E e) 💊
                    Это эквивалент постановки в очередь. Он добавляет элемент в конец двухсторонней очереди.
                                        
                    💊 public int size() 💊
                    Возвращает размер (длину) очереди.
                                        
                    💊 public E remove() 💊
                    Это эквивалент исключения из очереди. Удаляет элемент из начала списка.
                                        
                    💊 public E peek() 💊
                    Считывает элемент в начале двухсторонней очереди, не удаляя его.
                                        
                    💊 public void push(E e) 💊
                    Добавляет элемент в начало очереди.
                                        
                    💊 public E pop() 💊
                    Удаляет и возвращает первый элемент очереди.
                                        
                    💊 public void forEach(Consumer<? super E> action) 💊
                    Этот метод forEach можно использовать для доступа к каждому элементу в двухсторонней очереди.
                                        
                    💊 Iterator<E> iterator() 💊
                    Возвращает итератор, который можно использовать для удаления элемента внутри двухсторонней очереди. Однако это действие занимает больше времени, чем удаление элемента в начале или в конце очереди.\s
                    """;
    }

    public static String hashSet() {
            return """
                    💊	boolean add(Object o) 💊
                    Добавляет указанный элемент к этому набору, если он еще не присутствует.
                    
                    💊	void clear() 💊
                    Удаляет все элементы из этого набора.
                    
                    💊	Object clone() 💊
                    Возвращает мелкую копию этого экземпляра HashSet: сами элементы не клонируются.
                    
                    💊	boolean contains(Object o) 💊
                    Возвращает true, если этот набор содержит указанный элемент.
                    
                    💊	boolean isEmpty() 💊
                    Возвращает true, если этот набор не содержит элементов.
                    
                    💊	Iterator iterator() 💊
                    Возвращает итератор по элементам этого набора.
                    
                    💊	boolean remove(Object o) 💊
                    Удаляет указанный элемент из этого набора, если он присутствует.
                    
                    💊	int size() 💊
                    Возвращает количество элементов в этом наборе (его количество элементов).
                    """;
    }

    public static String treeSet() {
            return """
                    💊	void add(Object o) 💊
                    Добавляет указанный элемент к этому набору, если он еще не присутствует.
                    
                    💊	boolean addAll(Collection c) 💊
                    Добавляет все элементы в указанной коллекции к этому набору.
                    
                    💊	void clear() 💊
                    Удаляет все элементы из этого набора.
                    
                    💊	Object clone() 💊
                    Возвращает мелкую копию этого экземпляра TreeSet.
                    
                    💊	Comparator comparator() 💊
                    Возвращает компаратор, используемый для порядка этого отсортированного набора, или null (нуль), если этот набор деревьев использует свои элементы естественного упорядочения.
                    
                    💊	boolean contains(Object o) 💊
                    Возвращает true, если этот набор содержит указанный элемент.
                    
                    💊	Object first() 💊
                    Возвращает первый (самый низкий) элемент, находящийся в этом отсортированном наборе.
                    
                    💊	SortedSet headSet(Object toElement) 💊
                    Возвращает представление (вид) части этого набора, элементы которого строго меньше, чем toElement.
                    
                    💊	boolean isEmpty() 💊
                    Возвращает true, если этот набор не содержит элементов.
                    
                    💊	Iterator iterator() 💊
                    Возвращает итератор над элементами этого набора.
                    
                    💊	Object last() 💊
                    Возвращает последний (самый высокий) элемент, находящийся в этом отсортированном наборе.
                    
                    💊	boolean remove(Object o) 💊
                    Удаляет указанный элемент из этого набора, если он присутствует.
                    
                    💊	int size() 💊
                    Возвращает количество элементов в этом наборе (его мощность).
                    
                    💊	SortedSet subSet(Object fromElement, Object toElement) 💊
                    Возвращает представление (вид) части этого набора, элементы которого варьируются от fromElement, включительно, до toElement, исключительно.
                    
                    💊	SortedSet tailSet(Object fromElement)  💊
                    Возвращает представление (вид) части этого набора, элементы которого больше или равны fromElement.
                    """;
    }

    public static String linkedHashSet() {
            return """
                    💊	boolean add(Object o) 💊
                    Добавляет указанный элемент к этому набору, если он еще не присутствует.
                    
                    💊	void clear() 💊
                    Удаляет все элементы из этого набора.
                    
                    💊	Object clone() 💊
                    Возвращает мелкую копию этого экземпляра HashSet: сами элементы не клонируются.
                    
                    💊	boolean contains(Object o) 💊
                    Возвращает true, если этот набор содержит указанный элемент.
                    
                    💊	boolean isEmpty() 💊
                    Возвращает true, если этот набор не содержит элементов.
                    
                    💊	Iterator iterator() 💊
                    Возвращает итератор по элементам этого набора.
                    
                    💊	boolean remove(Object o) 💊
                    Удаляет указанный элемент из этого набора, если он присутствует.
                    
                    💊	int size() 💊
                    Возвращает количество элементов в этом наборе (его количество элементов).
                    """;
    }

    public static String priorityQueue() {
            return """
                    💊 boolean add(E e): 💊
                     Этот метод используется для добавления указанного элемента в приоритетную очередь.
                                        
                    💊 void clear(): 💊
                     этот метод используется для удаления всех элементов из приоритетной очереди.
                                        
                    💊 comparator(): 💊
                     возвращает компаратор, используемый для упорядочения элементов очереди. Если очередь отсортирована в соответствии с естественным порядком ее элементов, она возвращает нулевой объект.
                                        
                    💊 boolean contains(Object o): 💊
                     возвращает true, если очередь содержит указанный элемент.
                                        
                    💊 Iterator<E> iterator(): 💊
                     возвращает итератор для элементов в приоритетной очереди.
                                        
                    💊 boolean offer(E e): 💊
                     используется для добавления указанного элемента в очередь приоритетов.
                                        
                    💊 E peek(): 💊
                     этот метод извлекает, но не удаляет элемент в начале очереди. Возвращает нулевой элемент, если очередь пуста.
                                        
                    💊 E poll(): 💊
                     этот метод извлекает и удаляет элемент в начале очереди. Он возвращает null, если эта очередь пуста.
                                        
                    💊 boolean remove(Object o): 💊
                     используется для удаления указанного элемента из очереди.
                                        
                    💊 int size(): 💊
                     возвращает количество элементов в очереди.
                                        
                    💊 Object[] toArray(): 💊
                    возвращает массив, содержащий все элементы, присутствующие в очереди.
                                        
                    💊 <T> T[ ] toArray(T[ ] a): 💊
                    этот метод возвращает массив, содержащий все элементы, присутствующие в очереди; тип возвращаемого массива во время выполнения совпадает с типом указанного массива.
                    """;
    }

    public static String hashMap() {
            return """
                    💊	void clear() 💊
                    Удаляет все соответствия с этого Map.
                    
                    💊	Object clone() 💊
                    Возвращает мелкую копию этого экземпляра HashMap: сами ключи и значения не клонируются.
                    
                    💊	boolean containsKey(Object key) 💊
                    Возвращает true, если этот Map содержит отображение для указанного ключа.
                    
                    💊	boolean containsValue(Object value) 💊
                    Возвращает true, если этот Map отображает одну или несколько клавиш в указанное значение.
                    
                    💊	Set entrySet() 💊
                    Возвращает представление (вид) коллекции отображений, содержащихся в этом Map.
                    
                    💊	Object get(Object key) 💊
                    Возвращает значение, для которого указанный ключ отображается в этой хэш-карте идентификатора, или null (нуль), если Map не содержит отображения для этого ключа.
                    
                    💊	boolean isEmpty() 💊
                    Возвращает true, если этот Map не содержит отображений значений ключа.
                    
                    💊	Set keySet() 💊
                    Возвращает заданное представление (вид) ключей, содержащихся на этом Map.
                    
                    💊	Object put(Object key, Object value) 💊
                    Связывает указанное значение с указанным ключом на этом Map.
                    
                    💊	putAll(Map m) 💊
                    Копирует все отображения с указанного Map на этот Map. Эти отображения заменят любые отображения, которые это отображение имело для любого из ключей, находящихся в настоящее время на указанном Map.
                    
                    💊	Object remove(Object key) 💊
                    Удаляет отображение для этого ключа с этого Map, если присутствует.
                    
                    💊	int size() 💊
                    Возвращает количество ключ-значение отображений на этом Map.
                    
                    💊	Collection values() 💊
                    Возвращает представление (вид) коллекции значений, содержащихся на этой карте.
                    """;
    }

    public static String treeMap() {
            return """
                    💊	void clear() 💊
                    Удаляет все отображения из этой TreeMap.
                    
                    💊	Object clone() 💊
                    Возвращает мелкую копию этого экземпляра TreeMap.
                    
                    💊	Comparator comparator() 💊
                    Возвращает компаратор, используемый для порядка этого Map, или null (нуль), если этот Map использует естественный порядок своих ключей.
                    
                    💊	boolean containsKey(Object key) 💊
                    Возвращает true, если этот Map содержит отображение для указанного ключа.
                    
                    💊	boolean containsValue(Object value) 💊
                    Возвращает true, если этот Map отображает одну или несколько клавиш в указанное значение.
                    
                    💊	Set entrySet() 💊
                    Возвращает заданный вид отображений, содержащихся в этом Map.
                    
                    💊	Object firstKey() 💊
                    Возвращает первый (самый низкий) ключ на этом сортированном Map.
                    
                    💊	Object get(Object key) 💊
                    Возвращает значение, на которое этот Map отображает указанный ключ.
                    
                    💊	SortedMap headMap(Object toKey) 💊
                    Возвращает представление (вид) части этого Map, ключи которой строго меньше, чем toKey.
                    
                    💊	Set keySet() 💊
                    Возвращает Set вид ключей, содержащихся в этом Map.
                    
                    💊	Object lastKey() 💊
                    Возвращает последний (самый высокий) ключ в настоящее время на этом отсортированном Map.
                    
                    💊	Object put(Object key, Object value) 💊
                    Связывает указанное значение с указанным ключом на этом Map.
                    
                    💊	void putAll(Map map) 💊
                    Копирует все отображения с указанного Map на этот Map.
                    
                    💊	Object remove(Object key) 💊
                    Удаляет отображение этого ключа из этого TreeMap, если оно присутствует.
                    
                    💊	int size() 💊
                    Возвращает количество отображений ключ-значение на этом Map.
                    
                    💊	SortedMap subMap(Object fromKey, Object toKey) 💊
                    Возвращает представление (вид) части этого Map, ключи которого варьируется от fromKey, включительно, до toKey, исключительно.
                    
                    💊	SortedMap tailMap(Object fromKey) 💊
                    Возвращает представление (вид) части этого Map, ключи которого больше или равны fromKey.
                    
                    💊	Collection values() 💊
                    Возвращает представление (вид) коллекции значений, содержащихся на этом Map.
                    """;
    }
    public static String arraysMethods() {
            return """
                   💊 boolean arrayContains(double[] array, double value) 💊
                   Возвращает true, если массив содержит заданное значение.
                                        
                   💊 boolean arrayContains(int[] array, int value) 💊
                   Возвращает true, если массив содержит заданное значение.
                                        
                   💊 boolean arrayContains(Object[] array, Object object) 💊
                   Возвращает true, если массив содержит заданное значение. Объекты сравниваются с помощью метода .equals(). Поддерживает массивы объектов любого типа. Например, при выполнении следующего кода в консоль будет выведено значение true:
                                        
                                        
                   💊 int indexOf(double[] array, double value) 💊
                   Возвращает индекс первого элемента массива, хранящего заданное значение. Возвращает -1, если значение не найдено или если массив пуст или не существует (равен null).
                                        
                   💊 int indexOf(int[] array, int value) 💊
                   Возвращает индекс первого элемента массива, хранящего заданное значение. Возвращает -1, если значение не найдено или если массив пуст или не существует (равен null).
                                        
                   💊 int indexOf(Object[] array, Object object) 💊
                   Возвращает индекс первого элемента массива, хранящего заданное значение. Объекты сравниваются с помощью метода .equals(). Возвращает -1, если значение не найдено или если массив пуст или не существует (равен null). Поддерживает массивы объектов любого типа. Например, при выполнении следующего кода в консоль будет выведено значение '1':
                                        
                   💊 int indexOf(int[] array, IntPredicate test) 💊
                   Возвращает индекс первого элемента массива, хранящего заданное значение. Возвращает -1, если значение не найдено или если массив пуст или не существует (равен null).
                                        
                   💊 int indexOf(double[] array, DoublePredicate test) 💊
                   Возвращает индекс первого элемента массива, хранящего заданное значение. Возвращает -1, если значение не найдено или если массив пуст или не существует (равен null).
                                        
                   💊 int indexOf(T[] array, Predicate<? super T> test) 💊
                   Возвращает индекс первого элемента массива, хранящего заданное значение. Объекты сравниваются с помощью метода .equals(). Возвращает -1, если значение не найдено или если массив пуст или не существует (равен null). Поддерживает массивы объектов любого типа. Например, при выполнении следующего кода в консоль будет выведено значение '1':
                                        
                   💊 int indexOfMax(double[] array) 💊
                   Возвращает индекс максимального значения, содержащегося в заданном массиве.
                                        
                   💊 int indexOfMax(int[] array) 💊
                   Возвращает индекс максимального значения, содержащегося в заданном массиве.
                                        
                   💊 int indexOfMin(double[] array) 💊
                   Возвращает индекс минимального значения, содержащегося в заданном массиве.
                                        
                   💊 int indexOfMin(int[] array) 💊
                   Возвращает индекс минимального значения, содержащегося в заданном массиве.
                                        
                   💊 double max(double[] array) 💊
                   Возвращает максимальное значение, содержащееся в заданном массиве. Выдает ошибку, если массив пуст или не существует (равен null).
                                        
                   💊 int max(int[] array) 💊
                   Возвращает максимальное значение, содержащееся в заданном массиве. Выдает ошибку, если массив пуст или не существует (равен null).
                                        
                   💊 double min(double[] array) 💊
                   Возвращает минимальное значение, содержащееся в заданном массиве. Выдает ошибку, если массив пуст или не существует (равен null).
                                        
                   💊 int min(int[] array) 💊
                   Возвращает минимальное значение, содержащееся в заданном массиве. Выдает ошибку, если массив пуст или не существует (равен null).
                    """;
    }
    public static String array() {
            return """
                    Массив — это структура данных, в которой хранятся элементы одного типа. Его можно представить, как набор пронумерованных ячеек, в каждую из которых можно поместить какие-то данные (один элемент данных в одну ячейку). Доступ к конкретной ячейке осуществляется через её номер. Номер элемента в массиве также называют индексом.\s
                    В случае с Java массив однороден, то есть во всех его ячейках будут храниться элементы одного типа. Так, массив целых чисел содержит только целые числа (например, типа int), массив строк — только строки, массив из элементов созданного нами класса Dog будет содержать только объекты Dog. То есть в Java мы не можем поместить в первую ячейку массива целое число, во вторую String, а в третью — “собаку”.\s
                                        
                    Одномерные и двумерные массивы
                    Если в массиве для обращения к элементам используется только один порядковый номер, то такой массив называется линейным, или одномерным. Одномерный массив можно представить в виде таблицы, в которой существует только одна строка.
                    Количество индексов элементов массива определяет размерность массива.
                    Массивы с двумя индексами называют двумерными. Такие массивы можно представить в виде таблицы, в которой номер строки соответствует первому индексу, а номер ячейки в строке (номер столбца) - второму индексу.
                    """;
    }
    public static String start() {
            return """
                     этот бот я пишу для себя, но если он поможет и вам, то буду очень рад, бот потихоньку будет дорабатываться.
                     Я планирую добавлять сюда, все новые и новые статьи, и в целом с учетом безграничности моего любимого языка, можно постоянно что то добавить или дополнить уже существующее, разные фреймворки, библиотеки с их классами и методами.
                    """;
    }
    public static String initialize() {
            return """
                    Ниже будут приведены примеры работы с массивами в среде разработки IntelijIdea выберите интересующий вас пункт что бы посмотреть как это выглядит в коде.
                    """;

    }
    public static String multidimensionalArray() {
            return """
                    Массивы очень облегчают жизнь программисту, но что если нужно что то большее? например нам надо запрограммировать шахматное поле или поле для шашек, для этого в java есть многомерные массивы, это так сказать массив который содержит массивы, что то вроде таблицы например двумерный массив doubleArrayInitialization можно представить как таблицу
                    
                               1, 2, 3.
                               4, 5, 6.
                               7, 8, 9.
                    
                    это массив содержащий 3 массива по 3 элемента каждый, так например массив doubleArray содержит в себе 10 массивов, по 10 элементов каждый, но что если нам нужен массив, который содержит в себе массивы разной длины? Для этого существуют так называемые зубчатые массивы, вы можете посмотреть как он создается и инициализируется, на фото на примере создания многомерного массива array
                    """;
    }
    public static String arrayCycle() {
            return """
                    при работе с массивами, очень часто приходится прибегать к помощи циклов, ниже приведены примеры работы с массивами при помощи циклов, заполнение, вывод на экран и прочее, выберите интересующий вас пункт, что бы посмотреть на примеры использования массивов в циклах.
                    """;
    }
    public static String arrayInitialization() {
            return """
                    В случае если вам нужно заполнить какой то очень большой массив, будь то в 100 в 1000 или в любое другое количество элементов, заполнять их вручную было бы мягко говоря долго, в случае если есть какая то логика которую можно выразить в алгоритме, то при помощи реализации этого алгоритма в цикле, вы можете заполнить массив нужными вам данными.
                    """;
    }

    public static String bubbleSorted() {
            return """
                    Сортировка пузырьком — один из самых известных алгоритмов сортировки. Здесь нужно последовательно сравнивать значения соседних элементов и менять числа местами, если предыдущее оказывается больше последующего. Таким образом элементы с большими значениями оказываются в конце списка, а с меньшими остаются в начале.
                    Этот алгоритм считается учебным и почти не применяется на практике из-за низкой эффективности: он медленно работает на тестах, в которых маленькие элементы (их называют «черепахами») стоят в конце массива. Однако на нём основаны многие другие методы, например, шейкерная сортировка и сортировка расчёской.
                    """;
    }

    public static String arraySorted() {
            return """
                    Задача алгоритмов сортировки состоит в том, что в произвольной последовательности элементов списка, нужно расположить их таким образом, чтобы каждое последующее значение ключа сортировки было больше предыдущего, в случае сортировки по возрастанию. Если производится сортировка по убыванию, каждое последующее значение ключа, соответственно, должно быть меньше предыдущего.
                    есть множество разных алгоритмов, некоторые из них вы можете посмотреть выбрав его в списке ниже
                    """;
    }

    public static String shakerSorted() {
            return """
                    
                    Шейкерная сортировка отличается от пузырьковой тем, что она двунаправленная: алгоритм перемещается не строго слева направо, а сначала слева направо, затем справа налево.
                    """;
    }

    public static String combSorted() {
            return """
                    Сортировка расчёской — улучшение сортировки пузырьком. Её идея состоит в том, чтобы «устранить» элементы с небольшими значения в конце массива, которые замедляют работу алгоритма. Если при пузырьковой и шейкерной сортировках при переборе массива сравниваются соседние элементы, то при «расчёсывании» сначала берётся достаточно большое расстояние между сравниваемыми значениями, а потом оно сужается вплоть до минимального.
                    Первоначальный разрыв нужно выбирать не случайным образом, а с учётом специальной величины — фактора уменьшения, оптимальное значение которого равно 1,247. Сначала расстояние между элементами будет равняться размеру массива, поделённому на 1,247; на каждом последующем шаге расстояние будет снова делиться на фактор уменьшения — и так до окончания работы алгоритма.
                    """;
    }

    public static String interviewEe() {
            return """
                Далее будет ряд тем, выбрав который вы перейдете к ряду вопросов, нажав на который, вы сможете посмотреть ответ.
                """;
    }

    public static String www() {
            return """
                    Всемирная паутина (англ. World Wide Web) — распределённая система, предоставляющая доступ к связанным между собой документам, расположенным на различных компьютерах, подключённых к Интернету. Для обозначения Всемирной паутины также используют слово веб (англ. web «паутина») и аббревиатуру WWW.
                                        
                    Всемирную паутину образуют сотни миллионов веб-серверов. Большинство ресурсов Всемирной паутины основаны на технологии гипертекста. Гипертекстовые документы, размещаемые во Всемирной паутине, называются веб-страницами. Несколько веб-страниц, объединённых общей темой, дизайном, а также связанных между собой ссылками и обычно находящихся на одном и том же веб-сервере, называются веб-сайтом. Для загрузки и просмотра веб-страниц используются специальные программы — браузеры (англ. browser).
                    """;
    }

    public static String w3c() {
            return """
                    Консорциум Всемирной паутины (англ. World Wide Web Consortium, W3C) — организация, разрабатывающая и внедряющая технологические стандарты для Всемирной паутины. Консорциум возглавляет сэр Тимоти Джон Бернерс-Ли, автор множества разработок в области информационных технологий.
                    """;
    }

    public static String tcpIp() {
            return """
                    Стек протоколов TCP/IP — набор сетевых протоколов передачи данных, используемых в сетях, включая сеть Интернет. Название TCP/IP происходит из двух наиважнейших протоколов семейства — Transmission Control Protocol (TCP) и Internet Protocol (IP), которые были разработаны и описаны первыми в данном стандарте.
                                        
                    Стек протоколов TCP/IP включает в себя четыре уровня:
                                        
                    прикладной уровень (application layer),
                    транспортный уровень (transport layer),
                    сетевой уровень (Internet layer),
                    канальный уровень (link layer).
                    """;
    }

    public static String ftp() {
            return """
                    FTP (англ. File Transfer Protocol — протокол передачи файлов) — стандартный протокол, предназначенный для передачи файлов по TCP-сетям (например, Интернет). Использует 21-й порт. FTP часто используется для загрузки сетевых страниц и других документов с частного устройства разработки на открытые сервера хостинга.
                                        
                    Протокол построен на архитектуре «клиент-сервер» и использует разные сетевые соединения для передачи команд и данных между клиентом и сервером. Пользователи FTP могут пройти аутентификацию, передавая логин и пароль открытым текстом, или же, если это разрешено на сервере, они могут подключиться анонимно. Можно использовать протокол SSH для безопасной передачи, скрывающей (шифрующей) логин и пароль, а также шифрующей содержимое.
                    """;
    }

    public static String httpHttps() {
            return """
                    HTTP (англ. HyperText Transfer Protocol — «протокол передачи гипертекста») — протокол прикладного уровня передачи данных (изначально — в виде гипертекстовых документов в формате HTML, в настоящий момент используется для передачи произвольных данных). Основой HTTP является технология «клиент-сервер», то есть предполагается существование потребителей (клиентов), которые инициируют соединение и посылают запрос, и поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.
                                        
                    HTTPS (аббр. от англ. HyperText Transfer Protocol Secure) — расширение протокола HTTP, поддерживающее шифрование. Данные, передаваемые по протоколу HTTPS, «упаковываются» в криптографический протокол SSL или TLS. В отличие от HTTP, для HTTPS по умолчанию используется TCP-порт 443.
                                        
                    HTTPS – не самостоятельный протокол передачи данных, а HTTP с надстройкой шифрования. В этом ключевое и единственное отличие.
                                        
                    HTTP – непосредственно протокол передачи данных, HTTPS – расширение этого протокола.
                    
                    HTTPS используется для защищенного посредством шифрования  обмена данными.
                    
                    HTTPS применяется в том числе и для авторизации на серверах, требующих повышенного внимания к безопасности данных.
                    
                    HTTP работает с портом 80, HTTPS – с портом 443.
                    """;
    }

    public static String dateTransfer() {
            return """
                    Протокол передачи данных — набор соглашений интерфейса логического уровня, которые определяют обмен данными между различными программами.
                                        
                    Примеры сетевых протоколов
                    TCP/IP — набор протоколов передачи данных, получивший название от двух принадлежащих ему протоколов: TCP (Transmission Control Protocol) и IP (Internet Protocol)
                                        
                    Наиболее известные протоколы, используемые в сети Интернет:
                                        
                    HTTP (Hyper Text Transfer Protocol) — это протокол передачи гипертекста. Протокол HTTP используется при пересылке Web-страниц между компьютерами, подключенными к одной сети.
                    
                    FTP (File Transfer Protocol) — это протокол передачи файлов со специального файлового сервера на компьютер пользователя. FTP дает возможность абоненту обмениваться двоичными и текстовыми файлами с любым компьютером сети. Установив связь с удаленным компьютером, пользователь может скопировать файл с удаленного компьютера на свой или скопировать файл со своего компьютера на удаленный.
                    
                    POP (Post Office Protocol) — это стандартный протокол почтового соединения. Серверы POP обрабатывают входящую почту, а протокол POP предназначен для обработки запросов на получение почты от клиентских почтовых программ.
                    
                    SMTP (Simple Mail Transfer Protocol) — протокол, который задает набор правил для передачи почты. Сервер SMTP возвращает либо подтверждение о приеме, либо сообщение об ошибке, либо запрашивает дополнительную информацию.
                    
                    TELNET — это протокол удаленного доступа. TELNET дает возможность абоненту работать на любой ЭВМ находящейся с ним в одной сети, как на своей собственной, то есть запускать программы, менять режим работы и так далее. На практике возможности ограничиваются тем уровнем доступа, который задан администратором удаленной машины.
                    """;
    }

    public static String webServer() {
            return """
                    Веб-сервер — сервер, принимающий HTTP-запросы от клиентов, обычно веб-браузеров, и выдающий им HTTP-ответы, как правило, вместе с HTML-страницей, изображением, файлом, медиа-потоком или другими данными.
                                        
                    Веб-сервером называют как программное обеспечение, выполняющее функции веб-сервера, так и непосредственно компьютер (см.: Сервер (аппаратное обеспечение)), на котором это программное обеспечение работает.
                    """;
    }

    public static String webApplication() {
            return """
                    Веб-приложение — клиент-серверное приложение, в котором клиентом выступает браузер, а сервером — веб-сервер. Логика веб-приложения распределена между сервером и клиентом, хранение данных осуществляется, преимущественно, на сервере, обмен информацией происходит по сети.
                    """;
    }

    public static String applicationServer() {
            return """
                    Сервер приложений (англ. application server) — это программная платформа (фреймворк), предназначенная для эффективного исполнения процедур (программ, скриптов), на которых построены приложения. Сервер приложений действует как набор компонентов, доступных разработчику программного обеспечения через API (Интерфейс прикладного программирования), определённый самой платформой.
                                        
                    Для веб-приложений основная задача компонентов сервера — обеспечивать создание динамических страниц. Однако современные серверы приложений включают в себя и поддержку кластеризации, повышенную отказоустойчивость, балансировку нагрузки, позволяя таким образом разработчикам сфокусироваться только на реализации бизнес-логики.
                    """;
    }

    public static String differenceWebAndApplication() {
            return """
                    Сервер приложений (англ. application server) — сервер, исполняющий некоторые прикладные программы. Сервер-приложений — объект, который обрабатывает запросы, связанные с приложениями, точнее для выполнения прикладных процессов (выборка данных, поиск данных, работа с терминалами). По идее эта технология изначально вообще не была связана с Web’om, однако, сейчас чаще говорят сервер web приложений. Практически используется для работы с базами данных.
                                        
                    Веб-сервер — это сервер, принимающий HTTP-запросы от клиентов, обычно веб-браузеров, и выдающий им HTTP-ответы. Web-сервер — объект, который обрабатывает запросы, в частности http-запросы. Браузер в данном случае клиент, который делает запросы (POST, GET).
                    """;
    }

    public static String getAndPost() {
            return """
                    Метод GET.
                    Метод GET удобен тем, что прост в эксплуатации. Но у него есть недостатки. Во-первых, методом GET нельзя передавать большие объемы информации, потому что данные, передаваемые этим методом входят в состав URL, длина которого ограничена. Так как данные, передаваемые методом GET входят в состав URL документа, их может подсмотреть любой желающий. У этого есть преимущества и недостатки. Преимущество состоит в том, что можно послать ссылку вместе с данными другу. Недостаток в том, что в строке браузера отображается и ваш, только что введенный пароль. Это одна из причин, почему данные, представляющие ценность, всегда нужно передавать методом POST.
                                        
                    Метод POST.
                    Как и метод GET, метод POST служит для передачи данных на сервер. Однако, данные, переданные таким образом, идут не в URL документа, а в теле запроса, после заголовков. Эти данные могут быть восприняты CGI-программой.
                                        
                    Когда данные отправляются методом POST, серверу приходит что-то вроде: (Смотрите пример на фото)
                                        
                                        
                    Плюсы метода POST очевидны: можно передавать неограниченные объемы информации, причем, никто не увидит эту информацию после того, как вы ее отправили (имеется ввиду, в строке браузера).
                                        
                    Но есть и недостатки:
                                        
                    Медленнее, чем GET, так как анализируются заголовки и тело запроса.
                    Страницы, сгенерированные как результат запроса POST, нельзя добавить в закладки (СЕО-недружелюбен)
                    Кроме того, если необходимо «протащить» данные через несколько форм или страниц, то это вызовет дополнительные трудности.
                    """;
    }

    public static String whatHtml() {
            return """
                    HTML – это язык разметки. Вы используете HTML для разметки текстового документа, точно так же, как это делает редактор при помощи жирного красного карандаша. Эти пометки служат для определения формата (или стиля), который будет использован при выводе текста на экран монитора.
                    """;
    }

    public static String whatXml() {
            return """
                    XML, или Язык Расширяемой Маркировки — eXtensible Markup Language, — спроектирован для того, чтобы предоставить Web-разработчикам возможность определения содержания более сложных документов, причем с более корректным “отображением данных”, нежели ранее. XML разрабатывался как язык с простым формальным синтаксисом, удобный для создания и обработки документов программам и одновременно удобный для чтения и создания документов человеком, с подчёркиванием нацеленности на использование в Интернете. Язык называется расширяемым, поскольку он не фиксирует разметку, используемую в документах: разработчик волен создать разметку в соответствии с потребностями к конкретной области, будучи ограниченным лишь синтаксическими правилами языка.
                    """;
    }

    public static String whatCss() {
            return """
                    CSS (Cascading Style Sheets — каскадные таблицы стилей) – одна из базовых технологий в современном Интернете. Нечасто можно встретить сайт, свёрстанный без применения CSS. CSS-код – это список инструкций для браузера, – как и где отображать элементы веб-страницы, написанный особым образом.
                    """;
    }

    public static String mimeType() {
            return """
                    MIME (Multipurpose Internet Mail Extensions, многоцелевые расширения интернет-почты) — стандарт Интернет, является частью протокола HTTP. Задача MIME это идентификация типа содержимого документа по его заголовку. К примеру, текстовый файл имеет тип text/plain, а HTML-файл — text/html. Отправка заголовка обычно происходит на основе расширения файла веб-сервером.
                    Internet Media Types — типы данных, которые могут быть переданы посредством сети интернет с применением стандарта MIME. Ниже приведен список MIME-заголовков и расширений файлов.
                                        
                    Согласно RFC 2045, RFC 2046, RFC 4288, RFC 4289 и RFC 4855[2] выделяются следующие базовые типы передаваемых данных:application, audio, example, image, message, model, multipart, text, video.
                    """;
    }

    public static String whatCookies() {
            return """
                    Куки (от англ. cookie — печенье) — небольшой фрагмент данных, отправленный веб-сервером и хранимый на компьютере пользователя. Веб-клиент (обычно веб-браузер) всякий раз при попытке открыть страницу соответствующего сайта пересылает этот фрагмент данных веб-серверу в составе HTTP-запроса. Применяется для сохранения данных на стороне пользователя, на практике обычно используется для:
                                        
                    аутентификации пользователя;
                    хранения персональных предпочтений и настроек пользователя;
                    отслеживания состояния сеанса[en] доступа пользователя;
                    ведения статистики о пользователях.
                    """;
    }

    public static String whatSession() {
            return """
                    Сессия (от англ. session) – промежуток времени между первым и последним запросами, которые пользователь отправляет со своего устройства (компьютера, телефона) к серверу сайта. Во время одной сессии посетитель совершает какие-либо активные действия: переходит по ссылкам, заполняет формы, скачивает данные – вся подобная информация записывается и хранится в так называемом лог-файле сайта. Завершается сессия в случае, если со стороны пользователя не поступало запросов в течение определенного промежутка времени или же при обрыве связи.
                    """;
    }

    public static String authorizationAuthentication() {
            return """
                    Авторизация (англ. authorization — разрешение, уполномочивание) — предоставление определённому лицу или группе лиц прав на выполнение определённых действий; а также процесс проверки (подтверждения) данных прав при попытке выполнения этих действий. Часто можно услышать выражение, что какой-то человек «авторизован» для выполнения данной операции — это значит, что он имеет на неё право.
                                        
                    Аутентификация — процедура проверки подлинности, например:
                                        
                    проверка подлинности пользователя путём сравнения введённого им логина и пароля, сохранённым в базе данных пользователей;
                    подтверждение подлинности электронного письма путём проверки цифровой подписи письма по открытому ключу отправителя;
                    проверка контрольной суммы файла на соответствие сумме, заявленной автором этого файла.
                    Авторизацию не следует путать с аутентификацией: аутентификация — это процедура проверки легальности пользователя или данных, например, проверки соответствия введённого пользователем пароля к учётной записи паролю в базе данных, или проверка цифровой подписи письма по ключу шифрования, или проверка контрольной суммы файла на соответствие заявленной автором этого файла. Авторизация же производит контроль доступа легальных пользователей к ресурсам системы после успешного прохождения ими аутентификации. Зачастую процедуры аутентификации и авторизации совмещаются.
                    """;
    }

    public static String whatAjax() {
            return """
                    AJAX — это аббревиатура, которая означает Asynchronous Javascript and XML. При использовании AJAX нет необходимости обновлять каждый раз всю страницу, так как обновляется только ее конкретная часть. Достоинства AJAX:
                                        
                    Возможность создания удобного Web-интерфейса
                    Активное взаимодействие с пользователем
                    Частичная перезагрузка страницы, вместо полной
                    Удобство использования
                    AJAX использует два метода работы с веб-страницей: изменение Web-страницы не перезагружая её, и динамическое обращение к серверу. Второе может осуществляться несколькими способами, в частности, XMLHttpRequest, о чем мы и будем говорить, и использование техники скрытого фрейма. Для того, чтобы осуществлять обмен данными, на странице должен быть создан объект XMLHttpRequest, который является своеобразным посредником между браузером пользователя и сервером. С помощью XMLHttpRequest можно отправить запрос на сервер, а также получить ответ в виде различного рода данных.
                    """;
    }

    public static String whatOrm() {
            return """
                    ORM (англ. Object-Relational Mapping, рус. объектно-реляционное отображение) — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных». Существуют как проприетарные, так и свободные реализации этой технологии.
                    """;
    }

    public static String dataTransferMethods() {
            return """
                    GET — получение ресурса
                    POST — создание ресурса
                    PUT — обновление ресурса
                    DELETE — удаление ресурса
                    Основными являются методы POST и GET.
                    """;
    }
    public static String dockerRun() {
            return """
                    docker run -d -p 80:80 docker/geeting-started ->
                    -> Первое слово docker говорит о том что мы обращаемся к докеру, команда run позволяет на запустить так называемый контейнер.
                    Так же команда run проверяет есть ли проект, и если его у нас не окажется, то команда run дополнительно докачает проект.
                    -d и -p являются опциями опция -d позволяет запустить контейнер, на заднем фоне. -р позволяет нам соединить порты
                    """;
    }
}
